import { dirname, resolve, normalize, relative, extname, basename, isAbsolute, join, parse } from 'pathe';
import { createHooks } from 'hookable';
import { resolveFiles, useNuxt, defineNuxtModule, addPlugin, addVitePlugin, addWebpackPlugin, addTemplate, isNuxt3, isIgnored, resolveAlias, addPluginTemplate, logger, nuxtCtx, addComponent, installModule, loadNuxtConfig, templateUtils, normalizeTemplate, compileTemplate, findPath, normalizePlugin, tryImportModule } from '@nuxt/kit';
import { existsSync, statSync, promises } from 'fs';
import { genArrayFromRaw, genImport, genDynamicImport, genObjectFromRawEntries, genString, genExport } from 'knitwork';
import escapeRE from 'escape-string-regexp';
import { fileURLToPath } from 'url';
import { encodePath, parseURL, parseQuery, withQuery } from 'ufo';
import { pascalCase, kebabCase, splitByCase, camelCase } from 'scule';
import { createUnplugin } from 'unplugin';
import { findStaticImports, findExports } from 'mlly';
import MagicString from 'magic-string';
import defu from 'defu';
import { globby } from 'globby';
import { createRequire } from 'module';
import chokidar from 'chokidar';

let _distDir = dirname(fileURLToPath(import.meta.url));
if (_distDir.endsWith("chunks")) {
  _distDir = dirname(_distDir);
}
const distDir = _distDir;
const pkgDir = resolve(distDir, "..");
resolve(distDir, "runtime");

async function resolvePagesRoutes(nuxt) {
  const pagesDir = resolve(nuxt.options.srcDir, nuxt.options.dir.pages);
  const files = await resolveFiles(pagesDir, `**/*{${nuxt.options.extensions.join(",")}}`);
  files.sort();
  return generateRoutesFromFiles(files, pagesDir);
}
function generateRoutesFromFiles(files, pagesDir) {
  const routes = [];
  for (const file of files) {
    const segments = relative(pagesDir, file).replace(new RegExp(`${escapeRE(extname(file))}$`), "").split("/");
    const route = {
      name: "",
      path: "",
      file,
      children: []
    };
    let parent = routes;
    for (let i = 0; i < segments.length; i++) {
      const segment = segments[i];
      const tokens = parseSegment(segment);
      const segmentName = tokens.map(({ value }) => value).join("");
      const isSingleSegment = segments.length === 1;
      const isLastSegment = i === segments.length - 1;
      route.name += (route.name && "-") + segmentName;
      const child = parent.find((parentRoute) => parentRoute.name === route.name);
      if (child) {
        parent = child.children;
        route.path = "";
      } else if (segmentName === "404" && isSingleSegment) {
        route.path += "/:catchAll(.*)*";
      } else if (segmentName === "index" && !route.path) {
        route.path += "/";
      } else if (segmentName !== "index") {
        route.path += getRoutePath(tokens);
        if (isLastSegment && tokens.length === 1 && tokens[0].type === 1 /* dynamic */) {
          route.path += "?";
        }
      }
    }
    parent.push(route);
  }
  return prepareRoutes(routes);
}
function getRoutePath(tokens) {
  return tokens.reduce((path, token) => {
    return path + (token.type === 1 /* dynamic */ ? `:${token.value}` : token.type === 2 /* catchall */ ? `:${token.value}(.*)*` : encodePath(token.value));
  }, "/");
}
const PARAM_CHAR_RE = /[\w\d_.]/;
function parseSegment(segment) {
  let state = 0 /* initial */;
  let i = 0;
  let buffer = "";
  const tokens = [];
  function consumeBuffer() {
    if (!buffer) {
      return;
    }
    if (state === 0 /* initial */) {
      throw new Error("wrong state");
    }
    tokens.push({
      type: state === 1 /* static */ ? 0 /* static */ : state === 2 /* dynamic */ ? 1 /* dynamic */ : 2 /* catchall */,
      value: buffer
    });
    buffer = "";
  }
  while (i < segment.length) {
    const c = segment[i];
    switch (state) {
      case 0 /* initial */:
        buffer = "";
        if (c === "[") {
          state = 2 /* dynamic */;
        } else {
          i--;
          state = 1 /* static */;
        }
        break;
      case 1 /* static */:
        if (c === "[") {
          consumeBuffer();
          state = 2 /* dynamic */;
        } else {
          buffer += c;
        }
        break;
      case 3 /* catchall */:
      case 2 /* dynamic */:
        if (buffer === "...") {
          buffer = "";
          state = 3 /* catchall */;
        }
        if (c === "]") {
          if (!buffer) {
            throw new Error("Empty param");
          } else {
            consumeBuffer();
          }
          state = 0 /* initial */;
        } else if (PARAM_CHAR_RE.test(c)) {
          buffer += c;
        } else ;
        break;
    }
    i++;
  }
  if (state === 2 /* dynamic */) {
    throw new Error(`Unfinished param "${buffer}"`);
  }
  consumeBuffer();
  return tokens;
}
function prepareRoutes(routes, parent) {
  for (const route of routes) {
    if (route.name) {
      route.name = route.name.replace(/-index$/, "");
    }
    if (route.path === "/") {
      routes.forEach((siblingRoute) => {
        if (siblingRoute.path.endsWith("?")) {
          siblingRoute.path = siblingRoute.path.slice(0, -1);
        }
      });
    }
    if (parent && route.path.startsWith("/")) {
      route.path = route.path.slice(1);
    }
    if (route.children.length) {
      route.children = prepareRoutes(route.children, route);
    }
    if (route.children.find((childRoute) => childRoute.path === "")) {
      delete route.name;
    }
  }
  return routes;
}
async function resolveLayouts(nuxt) {
  const layoutDir = resolve(nuxt.options.srcDir, nuxt.options.dir.layouts);
  const files = await resolveFiles(layoutDir, `*{${nuxt.options.extensions.join(",")}}`);
  const layouts = files.map((file) => ({ name: getNameFromPath(file), file }));
  await nuxt.callHook("pages:layouts:extend", layouts);
  return layouts;
}
function normalizeRoutes(routes, metaImports = /* @__PURE__ */ new Set()) {
  return {
    imports: metaImports,
    routes: genArrayFromRaw(routes.map((route) => {
      const file = normalize(route.file);
      const metaImportName = getImportName(file) + "Meta";
      metaImports.add(genImport(`${file}?macro=true`, [{ name: "meta", as: metaImportName }]));
      return {
        ...Object.fromEntries(Object.entries(route).map(([key, value]) => [key, JSON.stringify(value)])),
        children: route.children ? normalizeRoutes(route.children, metaImports).routes : [],
        meta: route.meta ? JSON.stringify(route.meta) : metaImportName,
        component: genDynamicImport(file)
      };
    }))
  };
}
async function resolveMiddleware() {
  const nuxt = useNuxt();
  const middlewareDir = resolve(nuxt.options.srcDir, nuxt.options.dir.middleware);
  const files = await resolveFiles(middlewareDir, `*{${nuxt.options.extensions.join(",")}}`);
  const middleware = files.map((path) => ({ name: getNameFromPath(path), path, global: hasSuffix(path, ".global") }));
  await nuxt.callHook("pages:middleware:extend", middleware);
  return middleware;
}
function getNameFromPath(path) {
  return kebabCase(basename(path).replace(extname(path), "")).replace(/["']/g, "").replace(".global", "");
}
function hasSuffix(path, suffix) {
  return basename(path).replace(extname(path), "").endsWith(suffix);
}
function getImportName(name) {
  return pascalCase(name).replace(/[^\w]/g, "");
}

const TransformMacroPlugin = createUnplugin((options) => {
  return {
    name: "nuxt:pages-macros-transform",
    enforce: "post",
    transformInclude(id) {
      const { search, pathname } = parseURL(id);
      return pathname.endsWith(".vue") || !!parseQuery(search).macro;
    },
    transform(code, id) {
      const s = new MagicString(code);
      const { search } = parseURL(id);
      function result() {
        if (s.hasChanged()) {
          return { code: s.toString(), map: s.generateMap({ source: id, includeContent: true }) };
        }
      }
      for (const macro in options.macros) {
        const match = code.match(new RegExp(`\\b${macro}\\s*\\(\\s*`));
        if (match?.[0]) {
          s.overwrite(match.index, match.index + match[0].length, `/*#__PURE__*/ false && ${match[0]}`);
        }
      }
      if (!parseQuery(search).macro) {
        return result();
      }
      const scriptImport = findStaticImports(code).find((i) => parseQuery(i.specifier.replace("?macro=true", "")).type === "script");
      if (scriptImport) {
        const specifier = withQuery(scriptImport.specifier.replace("?macro=true", ""), { macro: "true" });
        s.overwrite(0, code.length, `export { meta } from "${specifier}"`);
        return result();
      }
      const currentExports = findExports(code);
      for (const match of currentExports) {
        if (match.type !== "default") {
          continue;
        }
        if (match.specifier && match._type === "named") {
          s.overwrite(match.start, match.end, `export {${Object.values(options.macros).join(", ")}} from "${match.specifier}"`);
          return result();
        } else if (!options.dev) {
          s.overwrite(match.start, match.end, "/*#__PURE__*/ false &&");
          s.append("\nexport default {}");
        }
      }
      for (const macro in options.macros) {
        if (currentExports.some((e) => e.name === options.macros[macro])) {
          continue;
        }
        const { 0: match, index = 0 } = code.match(new RegExp(`\\b${macro}\\s*\\(\\s*`)) || {};
        const macroContent = match ? extractObject(code.slice(index + match.length)) : "undefined";
        s.append(`
export const ${options.macros[macro]} = ${macroContent}`);
      }
      return result();
    }
  };
});
const starts = {
  "{": "}",
  "[": "]",
  "(": ")",
  "<": ">",
  '"': '"',
  "'": "'"
};
function extractObject(code) {
  code = code.replace(/^\s*\/\/.*$/gm, "");
  const stack = [];
  let result = "";
  do {
    if (stack[0] === code[0] && result.slice(-1) !== "\\") {
      stack.shift();
    } else if (code[0] in starts) {
      stack.unshift(starts[code[0]]);
    }
    result += code[0];
    code = code.slice(1);
  } while (stack.length && code.length);
  return result;
}

const pagesModule = defineNuxtModule({
  meta: {
    name: "router"
  },
  setup(_options, nuxt) {
    const pagesDir = resolve(nuxt.options.srcDir, nuxt.options.dir.pages);
    const runtimeDir = resolve(distDir, "pages/runtime");
    if (!existsSync(pagesDir)) {
      addPlugin(resolve(distDir, "app/plugins/router"));
      return;
    }
    nuxt.hook("prepare:types", ({ references }) => {
      references.push({ types: "vue-router" });
    });
    nuxt.hook("builder:watch", async (event, path) => {
      const dirs = [
        nuxt.options.dir.pages,
        nuxt.options.dir.layouts,
        nuxt.options.dir.middleware
      ].filter(Boolean);
      const pathPattern = new RegExp(`^(${dirs.map(escapeRE).join("|")})/`);
      if (event !== "change" && path.match(pathPattern)) {
        await nuxt.callHook("builder:generateApp");
      }
    });
    nuxt.hook("app:resolve", (app) => {
      if (app.mainComponent.includes("nuxt-welcome")) {
        app.mainComponent = resolve(runtimeDir, "app.vue");
      }
    });
    nuxt.hook("autoImports:extend", (autoImports) => {
      autoImports.push({ name: "definePageMeta", as: "definePageMeta", from: resolve(runtimeDir, "composables") });
    });
    const macroOptions = {
      dev: nuxt.options.dev,
      macros: {
        definePageMeta: "meta"
      }
    };
    addVitePlugin(TransformMacroPlugin.vite(macroOptions));
    addWebpackPlugin(TransformMacroPlugin.webpack(macroOptions));
    addPlugin(resolve(runtimeDir, "router"));
    addTemplate({
      filename: "routes.mjs",
      async getContents() {
        const pages = await resolvePagesRoutes(nuxt);
        await nuxt.callHook("pages:extend", pages);
        const { routes, imports } = normalizeRoutes(pages);
        return [...imports, `export default ${routes}`].join("\n");
      }
    });
    addTemplate({
      filename: "middleware.mjs",
      async getContents() {
        const middleware = await resolveMiddleware();
        const globalMiddleware = middleware.filter((mw) => mw.global);
        const namedMiddleware = middleware.filter((mw) => !mw.global);
        const namedMiddlewareObject = genObjectFromRawEntries(namedMiddleware.map((mw) => [mw.name, genDynamicImport(mw.path)]));
        return [
          ...globalMiddleware.map((mw) => genImport(mw.path, getImportName(mw.name))),
          `export const globalMiddleware = ${genArrayFromRaw(globalMiddleware.map((mw) => getImportName(mw.name)))}`,
          `export const namedMiddleware = ${namedMiddlewareObject}`
        ].join("\n");
      }
    });
    addTemplate({
      filename: "types/middleware.d.ts",
      getContents: async () => {
        const composablesFile = resolve(runtimeDir, "composables");
        const middleware = await resolveMiddleware();
        const namedMiddleware = middleware.filter((mw) => !mw.global);
        return [
          "import type { NavigationGuard } from 'vue-router'",
          `export type MiddlewareKey = ${namedMiddleware.map((mw) => genString(mw.name)).join(" | ") || "string"}`,
          `declare module ${genString(composablesFile)} {`,
          "  interface PageMeta {",
          "    middleware?: MiddlewareKey | NavigationGuard | Array<MiddlewareKey | NavigationGuard>",
          "  }",
          "}"
        ].join("\n");
      }
    });
    addTemplate({
      filename: "types/layouts.d.ts",
      getContents: async () => {
        const composablesFile = resolve(runtimeDir, "composables");
        const layouts = await resolveLayouts(nuxt);
        return [
          "import { ComputedRef, Ref } from 'vue'",
          `export type LayoutKey = ${layouts.map((layout) => genString(layout.name)).join(" | ") || "string"}`,
          `declare module ${genString(composablesFile)} {`,
          "  interface PageMeta {",
          "    layout?: false | LayoutKey | Ref<LayoutKey> | ComputedRef<LayoutKey>",
          "  }",
          "}"
        ].join("\n");
      }
    });
    addTemplate({
      filename: "layouts.mjs",
      async getContents() {
        const layouts = await resolveLayouts(nuxt);
        const layoutsObject = genObjectFromRawEntries(layouts.map(({ name, file }) => {
          return [name, `defineAsyncComponent({ suspensible: false, loader: ${genDynamicImport(file)} })`];
        }));
        return [
          "import { defineAsyncComponent } from 'vue'",
          `export default ${layoutsObject}`
        ].join("\n");
      }
    });
    nuxt.hook("prepare:types", ({ references }) => {
      references.push({ path: resolve(nuxt.options.buildDir, "types/middleware.d.ts") });
      references.push({ path: resolve(nuxt.options.buildDir, "types/layouts.d.ts") });
    });
  }
});

const metaModule = defineNuxtModule({
  meta: {
    name: "meta"
  },
  defaults: {
    charset: "utf-8",
    viewport: "width=device-width, initial-scale=1"
  },
  setup(options, nuxt) {
    const runtimeDir = nuxt.options.alias["#meta"] || resolve(distDir, "meta/runtime");
    nuxt.options.build.transpile.push("@vueuse/head");
    nuxt.options.alias["#meta"] = runtimeDir;
    const globalMeta = defu(nuxt.options.meta, {
      meta: [
        { charset: options.charset },
        { name: "viewport", content: options.viewport }
      ]
    });
    addTemplate({
      filename: "meta.config.mjs",
      getContents: () => "export default " + JSON.stringify({ globalMeta, mixinKey: isNuxt3() ? "created" : "setup" })
    });
    addPlugin({ src: resolve(runtimeDir, "plugin") });
    addPlugin({ src: resolve(runtimeDir, "lib/vueuse-head.plugin") });
  }
});

const createImportMagicComments = (options) => {
  const { chunkName, prefetch, preload } = options;
  return [
    `webpackChunkName: "${chunkName}"`,
    prefetch === true || typeof prefetch === "number" ? `webpackPrefetch: ${prefetch}` : false,
    preload === true || typeof preload === "number" ? `webpackPreload: ${preload}` : false
  ].filter(Boolean).join(", ");
};
const componentsTemplate = {
  filename: "components.mjs",
  getContents({ options }) {
    return `import { defineAsyncComponent } from 'vue'

const components = ${genObjectFromRawEntries(options.components.filter((c) => c.global === true).map((c) => {
      const exp = c.export === "default" ? "c.default || c" : `c['${c.export}']`;
      const comment = createImportMagicComments(c);
      return [c.pascalName, `defineAsyncComponent(${genDynamicImport(c.filePath, { comment })}.then(c => ${exp}))`];
    }))}

export default function (nuxtApp) {
  for (const name in components) {
    nuxtApp.vueApp.component(name, components[name])
    nuxtApp.vueApp.component('Lazy' + name, components[name])
  }
}
`;
  }
};
const componentsTypeTemplate = {
  filename: "types/components.d.ts",
  getContents: ({ options }) => `// Generated by components discovery
declare module 'vue' {
  export interface GlobalComponents {
${options.components.map((c) => `    '${c.pascalName}': typeof ${genDynamicImport(isAbsolute(c.filePath) ? relative(join(options.buildDir, "types"), c.filePath) : c.filePath, { wrapper: false })}['${c.export}']`).join(",\n")}
  }
}
export {}
`
};

function hyphenate(str) {
  return str.replace(/\B([A-Z])/g, "-$1").toLowerCase();
}
async function scanComponents(dirs, srcDir) {
  const components = [];
  const filePaths = /* @__PURE__ */ new Set();
  const scannedPaths = [];
  for (const dir of dirs) {
    const resolvedNames = /* @__PURE__ */ new Map();
    for (const _file of await globby(dir.pattern, { cwd: dir.path, ignore: dir.ignore })) {
      const filePath = join(dir.path, _file);
      if (scannedPaths.find((d) => filePath.startsWith(d)) || isIgnored(filePath)) {
        continue;
      }
      if (filePaths.has(filePath)) {
        continue;
      }
      filePaths.add(filePath);
      const prefixParts = [].concat(dir.prefix ? splitByCase(dir.prefix) : [], dir.pathPrefix !== false ? splitByCase(relative(dir.path, dirname(filePath))) : []);
      let fileName = basename(filePath, extname(filePath));
      if (fileName.toLowerCase() === "index") {
        fileName = dir.pathPrefix === false ? basename(dirname(filePath)) : "";
      }
      const fileNameParts = splitByCase(fileName);
      const componentNameParts = [];
      while (prefixParts.length && (prefixParts[0] || "").toLowerCase() !== (fileNameParts[0] || "").toLowerCase()) {
        componentNameParts.push(prefixParts.shift());
      }
      const componentName = pascalCase(componentNameParts) + pascalCase(fileNameParts);
      if (resolvedNames.has(componentName)) {
        console.warn(`Two component files resolving to the same name \`${componentName}\`:

 - ${filePath}
 - ${resolvedNames.get(componentName)}`);
        continue;
      }
      resolvedNames.set(componentName, filePath);
      const pascalName = pascalCase(componentName).replace(/["']/g, "");
      const kebabName = hyphenate(componentName);
      const shortPath = relative(srcDir, filePath);
      const chunkName = "components/" + kebabName;
      let component = {
        filePath,
        pascalName,
        kebabName,
        chunkName,
        shortPath,
        export: "default",
        global: dir.global,
        prefetch: Boolean(dir.prefetch),
        preload: Boolean(dir.preload)
      };
      if (typeof dir.extendComponent === "function") {
        component = await dir.extendComponent(component) || component;
      }
      if (!components.find((c) => c.pascalName === component.pascalName)) {
        components.push(component);
      }
    }
    scannedPaths.push(dir.path);
  }
  return components;
}

const loaderPlugin = createUnplugin((options) => ({
  name: "nuxt:components-loader",
  enforce: "post",
  transformInclude(id) {
    const { pathname, search } = parseURL(id);
    const query = parseQuery(search);
    return pathname.endsWith(".vue") && (query.type === "template" || !search);
  },
  transform(code, id) {
    return transform(code, id, options.getComponents());
  }
}));
function findComponent(components, name) {
  return components.find(({ pascalName, kebabName }) => [pascalName, kebabName].includes(name));
}
function transform(code, id, components) {
  let num = 0;
  let imports = "";
  const map = /* @__PURE__ */ new Map();
  const s = new MagicString(code);
  s.replace(/ _resolveComponent\("(.*?)"\)/g, (full, name) => {
    const component = findComponent(components, name);
    if (component) {
      const identifier = map.get(component) || `__nuxt_component_${num++}`;
      map.set(component, identifier);
      imports += genImport(component.filePath, [{ name: component.export, as: identifier }]);
      return ` ${identifier}`;
    }
    return full;
  });
  if (imports) {
    s.prepend(imports + "\n");
  }
  if (s.hasChanged()) {
    return {
      code: s.toString(),
      map: s.generateMap({ source: id, includeContent: true })
    };
  }
}

const isPureObjectOrString = (val) => !Array.isArray(val) && typeof val === "object" || typeof val === "string";
const isDirectory = (p) => {
  try {
    return statSync(p).isDirectory();
  } catch (_e) {
    return false;
  }
};
function compareDirByPathLength({ path: pathA }, { path: pathB }) {
  return pathB.split(/[\\/]/).filter(Boolean).length - pathA.split(/[\\/]/).filter(Boolean).length;
}
const componentsModule = defineNuxtModule({
  meta: {
    name: "components",
    configKey: "components"
  },
  defaults: {
    dirs: []
  },
  setup(componentOptions, nuxt) {
    let componentDirs = [];
    const components = [];
    const normalizeDirs = (dir, cwd) => {
      if (Array.isArray(dir)) {
        return dir.map((dir2) => normalizeDirs(dir2, cwd)).flat().sort(compareDirByPathLength);
      }
      if (dir === true || dir === void 0) {
        return [{ path: resolve(cwd, "components") }];
      }
      if (typeof dir === "string") {
        return {
          path: resolve(cwd, resolveAlias(dir, {
            ...nuxt.options.alias,
            "~": cwd
          }))
        };
      }
      if (dir && typeof dir === "object") {
        return {
          ...dir,
          path: resolve(cwd, resolveAlias(dir.path, {
            ...nuxt.options.alias,
            "~": cwd
          }))
        };
      }
      return [];
    };
    nuxt.hook("app:resolve", async () => {
      const allDirs = [
        ...normalizeDirs(componentOptions.dirs, nuxt.options.srcDir),
        ...nuxt.options._extends.map((layer) => normalizeDirs(layer.config.components, layer.cwd)).flat()
      ];
      await nuxt.callHook("components:dirs", allDirs);
      componentDirs = allDirs.filter(isPureObjectOrString).map((dir) => {
        const dirOptions = typeof dir === "object" ? dir : { path: dir };
        const dirPath = resolveAlias(dirOptions.path);
        const transpile = typeof dirOptions.transpile === "boolean" ? dirOptions.transpile : "auto";
        const extensions = (dirOptions.extensions || nuxt.options.extensions).map((e) => e.replace(/^\./g, ""));
        dirOptions.level = Number(dirOptions.level || 0);
        const present = isDirectory(dirPath);
        if (!present && basename(dirOptions.path) !== "components") {
          console.warn("Components directory not found: `" + dirPath + "`");
        }
        return {
          global: componentOptions.global,
          ...dirOptions,
          enabled: true,
          path: dirPath,
          extensions,
          pattern: dirOptions.pattern || `**/*.{${extensions.join(",")},}`,
          ignore: [
            "**/*{M,.m,-m}ixin.{js,ts,jsx,tsx}",
            "**/*.d.ts",
            ...dirOptions.ignore || []
          ],
          transpile: transpile === "auto" ? dirPath.includes("node_modules") : transpile
        };
      }).filter((d) => d.enabled);
      nuxt.options.build.transpile.push(...componentDirs.filter((dir) => dir.transpile).map((dir) => dir.path));
    });
    const options = { components, buildDir: nuxt.options.buildDir };
    addTemplate({
      ...componentsTypeTemplate,
      options
    });
    addPluginTemplate({
      ...componentsTemplate,
      options
    });
    nuxt.hook("app:templates", async () => {
      options.components = await scanComponents(componentDirs, nuxt.options.srcDir);
      await nuxt.callHook("components:extend", options.components);
    });
    nuxt.hook("prepare:types", ({ references }) => {
      references.push({ path: resolve(nuxt.options.buildDir, "types/components.d.ts") });
    });
    nuxt.hook("builder:watch", async (event, path) => {
      if (!["add", "unlink"].includes(event)) {
        return;
      }
      const fPath = resolve(nuxt.options.rootDir, path);
      if (componentDirs.find((dir) => fPath.startsWith(dir.path))) {
        await nuxt.callHook("builder:generateApp");
      }
    });
    const loaderOptions = { getComponents: () => options.components };
    addWebpackPlugin(loaderPlugin.webpack(loaderOptions));
    addVitePlugin(loaderPlugin.vite(loaderOptions));
  }
});

function toImportModuleMap(autoImports, isCJS = false) {
  const aliasKeyword = isCJS ? " : " : " as ";
  const map = {};
  for (const autoImport of autoImports) {
    if (!map[autoImport.from]) {
      map[autoImport.from] = /* @__PURE__ */ new Set();
    }
    map[autoImport.from].add(autoImport.name === autoImport.as ? autoImport.name : autoImport.name + aliasKeyword + autoImport.as);
  }
  return map;
}
function toImports(autoImports, isCJS = false) {
  const map = toImportModuleMap(autoImports, isCJS);
  if (isCJS) {
    return Object.entries(map).map(([name, imports]) => `const { ${Array.from(imports).join(", ")} } = require(${genString(name)});`).join("\n");
  } else {
    return Object.entries(map).map(([name, imports]) => genImport(name, Array.from(imports))).join("\n");
  }
}
function toExports(autoImports) {
  const map = toImportModuleMap(autoImports, false);
  return Object.entries(map).map(([name, imports]) => genExport(name, Array.from(imports))).join("\n");
}
function filterInPlace(arr, predicate) {
  let i = arr.length;
  while (i--) {
    if (!predicate(arr[i])) {
      arr.splice(i, 1);
    }
  }
}

const excludeRE = [
  /\bimport\s*([\s\S]+?)\s*from\b/g,
  /\bfunction\s*([\w_$]+?)\s*\(/g,
  /\b(?:const|let|var)\s+?(\[[\s\S]*?\]|\{[\s\S]*?\}|[\s\S]+?)\s*?[=;\n]/g
];
const importAsRE = /^.*\sas\s+/;
const separatorRE = /[,[\]{}\n]/g;
const multilineCommentsRE = /\/\*\s(.|[\r\n])*?\*\//gm;
const singlelineCommentsRE = /\/\/\s.*$/gm;
const templateLiteralRE = /\$\{(.*)\}/g;
const quotesRE = [
  /(["'])((?:\\\1|(?!\1)|.|\r)*?)\1/gm,
  /([`])((?:\\\1|(?!\1)|.|\n|\r)*?)\1/gm
];
function stripCommentsAndStrings(code) {
  return code.replace(multilineCommentsRE, "").replace(singlelineCommentsRE, "").replace(templateLiteralRE, "` + $1 + `").replace(quotesRE[0], '""').replace(quotesRE[1], "``");
}
const TransformPlugin = createUnplugin((ctx) => {
  return {
    name: "nuxt:auto-imports-transform",
    enforce: "post",
    transformInclude(id) {
      const { pathname, search } = parseURL(id);
      const { type, macro } = parseQuery(search);
      if (ctx.transform.exclude.some((pattern) => id.match(pattern))) {
        return false;
      }
      if (pathname.endsWith(".vue") && (type === "template" || type === "script" || macro || !search)) {
        return true;
      }
      if (pathname.match(/\.((c|m)?j|t)sx?$/g)) {
        return true;
      }
    },
    transform(code) {
      const stripped = stripCommentsAndStrings(code);
      const matched = new Set(Array.from(stripped.matchAll(ctx.matchRE)).map((i) => i[1]));
      for (const regex of excludeRE) {
        Array.from(stripped.matchAll(regex)).flatMap((i) => [
          ...i[1]?.split(separatorRE) || [],
          ...i[2]?.split(separatorRE) || []
        ]).map((i) => i.replace(importAsRE, "").trim()).forEach((i) => matched.delete(i));
      }
      if (!matched.size) {
        return null;
      }
      const isCJSContext = stripped.includes("require(");
      const matchedImports = Array.from(matched).map((name) => ctx.map.get(name)).filter(Boolean);
      const imports = toImports(matchedImports, isCJSContext);
      return imports + code;
    }
  };
});

const Nuxt3AutoImports = [
  {
    from: "#app",
    names: [
      "useAsyncData",
      "useLazyAsyncData",
      "defineNuxtComponent",
      "useNuxtApp",
      "defineNuxtPlugin",
      "useRuntimeConfig",
      "useState",
      "useFetch",
      "useLazyFetch",
      "useCookie",
      "useRequestHeaders",
      "useRouter",
      "useRoute",
      "defineNuxtRouteMiddleware",
      "navigateTo",
      "abortNavigation",
      "addRouteMiddleware"
    ]
  },
  {
    from: "#meta",
    names: [
      "useMeta"
    ]
  },
  {
    from: "vue-demi",
    names: [
      "isVue2",
      "isVue3"
    ]
  },
  {
    from: "vue",
    names: [
      "withCtx",
      "withDirectives",
      "withKeys",
      "withMemo",
      "withModifiers",
      "withScopeId",
      "onActivated",
      "onBeforeMount",
      "onBeforeUnmount",
      "onBeforeUpdate",
      "onDeactivated",
      "onErrorCaptured",
      "onMounted",
      "onRenderTracked",
      "onRenderTriggered",
      "onServerPrefetch",
      "onUnmounted",
      "onUpdated",
      "computed",
      "customRef",
      "isProxy",
      "isReactive",
      "isReadonly",
      "isRef",
      "markRaw",
      "proxyRefs",
      "reactive",
      "readonly",
      "ref",
      "shallowReactive",
      "shallowReadonly",
      "shallowRef",
      "toRaw",
      "toRef",
      "toRefs",
      "triggerRef",
      "unref",
      "watch",
      "watchEffect",
      "isShallow",
      "effect",
      "effectScope",
      "getCurrentScope",
      "onScopeDispose",
      "defineComponent",
      "defineAsyncComponent",
      "getCurrentInstance",
      "h",
      "inject",
      "nextTick",
      "provide",
      "useAttrs",
      "useCssModule",
      "useCssVars",
      "useSlots",
      "useTransitionState"
    ]
  }
];

async function scanForComposables(dir, autoImports) {
  if (!existsSync(dir)) {
    return;
  }
  const files = await resolveFiles(dir, [
    "*.{ts,js,mjs,cjs,mts,cts}",
    "*/index.{ts,js,mjs,cjs,mts,cts}"
  ]);
  await Promise.all(files.map(async (path) => {
    filterInPlace(autoImports, (i) => i.from !== path);
    const code = await promises.readFile(path, "utf-8");
    const exports = findExports(code);
    const defaultExport = exports.find((i) => i.type === "default");
    if (defaultExport) {
      let name = parse(path).name;
      if (name === "index") {
        name = parse(path.split("/").slice(0, -1).join("/")).name;
      }
      autoImports.push({ name: "default", as: camelCase(name), from: path });
    }
    for (const exp of exports) {
      if (exp.type === "named") {
        for (const name of exp.names) {
          autoImports.push({ name, as: name, from: path });
        }
      } else if (exp.type === "declaration") {
        autoImports.push({ name: exp.name, as: exp.name, from: path });
      }
    }
  }));
}

function createAutoImportContext(opts) {
  return {
    autoImports: [],
    map: /* @__PURE__ */ new Map(),
    matchRE: /__never__/,
    transform: {
      exclude: opts.transform.exclude || [/node_modules/]
    }
  };
}
function updateAutoImportContext(ctx) {
  const usedNames = /* @__PURE__ */ new Set();
  for (const autoImport of ctx.autoImports) {
    if (usedNames.has(autoImport.as)) {
      autoImport.disabled = true;
      console.warn(`Disabling duplicate auto import '${autoImport.as}' (imported from '${autoImport.from}')`);
    } else {
      usedNames.add(autoImport.as);
    }
  }
  ctx.autoImports = ctx.autoImports.filter((i) => i.disabled !== true);
  ctx.matchRE = new RegExp(`\\b(${ctx.autoImports.map((i) => escapeRE(i.as)).join("|")})\\b`, "g");
  ctx.map.clear();
  for (const autoImport of ctx.autoImports) {
    ctx.map.set(autoImport.as, autoImport);
  }
  return ctx;
}

const autoImportsModule = defineNuxtModule({
  meta: {
    name: "auto-imports",
    configKey: "autoImports"
  },
  defaults: {
    sources: Nuxt3AutoImports,
    global: false,
    dirs: [],
    transform: {
      exclude: void 0
    }
  },
  async setup(options, nuxt) {
    await nuxt.callHook("autoImports:sources", options.sources);
    options.sources = options.sources.filter((source) => source.disabled !== true);
    const ctx = createAutoImportContext(options);
    let composablesDirs = [
      join(nuxt.options.srcDir, "composables"),
      ...options.dirs
    ];
    await nuxt.callHook("autoImports:dirs", composablesDirs);
    composablesDirs = composablesDirs.map((dir) => normalize(dir));
    addTemplate({
      filename: "imports.mjs",
      getContents: () => toExports(ctx.autoImports)
    });
    nuxt.options.alias["#imports"] = join(nuxt.options.buildDir, "imports");
    if (nuxt.options.dev && options.global) {
      addPluginTemplate({
        filename: "auto-imports.mjs",
        getContents: () => {
          const imports = toImports(ctx.autoImports);
          const globalThisSet = ctx.autoImports.map((i) => `globalThis.${i.as} = ${i.as};`).join("\n");
          return `${imports}

${globalThisSet}

export default () => {};`;
        }
      });
    } else {
      addVitePlugin(TransformPlugin.vite(ctx));
      addWebpackPlugin(TransformPlugin.webpack(ctx));
    }
    const regenerateAutoImports = async () => {
      ctx.autoImports = options.sources.flatMap((source) => source.names.map((importName) => typeof importName === "string" ? { name: importName, as: importName, from: source.from } : { name: importName.name, as: importName.as || importName.name, from: source.from }));
      for (const composablesDir of composablesDirs) {
        await scanForComposables(composablesDir, ctx.autoImports);
      }
      await nuxt.callHook("autoImports:extend", ctx.autoImports);
      updateAutoImportContext(ctx);
    };
    await regenerateAutoImports();
    addDeclarationTemplates(ctx);
    nuxt.hook("prepare:types", ({ references }) => {
      references.push({ path: resolve(nuxt.options.buildDir, "types/auto-imports.d.ts") });
      references.push({ path: resolve(nuxt.options.buildDir, "imports.d.ts") });
    });
    nuxt.hook("builder:watch", async (_, path) => {
      const _resolved = resolve(nuxt.options.srcDir, path);
      if (composablesDirs.find((dir) => _resolved.startsWith(dir))) {
        await regenerateAutoImports();
        await nuxt.callHook("builder:generateApp");
      }
    });
  }
});
function addDeclarationTemplates(ctx) {
  const nuxt = useNuxt();
  const resolved = {};
  const r = (id) => {
    if (resolved[id]) {
      return resolved[id];
    }
    let path = resolveAlias(id);
    if (isAbsolute(path)) {
      path = relative(join(nuxt.options.buildDir, "types"), path);
    }
    path = path.replace(/\.[a-z]+$/, "");
    resolved[id] = path;
    return path;
  };
  addTemplate({
    filename: "imports.d.ts",
    getContents: () => toExports(ctx.autoImports)
  });
  addTemplate({
    filename: "types/auto-imports.d.ts",
    getContents: () => `// Generated by auto imports
declare global {
${ctx.autoImports.map((i) => `  const ${i.as}: typeof ${genDynamicImport(r(i.from), { wrapper: false })}['${i.name}']`).join("\n")}
}

export {}
`
  });
}

const version = "3.0.0-27439932.78761c2";

const _require = createRequire(import.meta.url);
const vueAppPatterns = (nuxt) => [
  [/^(nuxt3|nuxt)$/, "`nuxt3`/`nuxt` cannot be imported directly. Instead, import runtime Nuxt composables from `#app` or `#imports`."],
  [/nuxt\.config/, "Importing directly from a `nuxt.config` file is not allowed. Instead, use runtime config or a module."],
  [/(^|node_modules\/)@vue\/composition-api/],
  ...nuxt.options.modules.filter((m) => typeof m === "string").map((m) => [new RegExp(`^${escapeRE(m)}$`), "Importing directly from module entrypoints is not allowed."]),
  ...["#static-assets", "#static", "#config", "#assets", "#storage", "#server-middleware"].map((i) => [i, "Nitro aliases cannot be imported in the Vue part of your app."]),
  ...[/(^|node_modules\/)@nuxt\/kit/, /^@nuxt\/nitro/].map((i) => [i, "This module cannot be imported in the Vue part of your app."]),
  [new RegExp(escapeRE(resolve(nuxt.options.srcDir, nuxt.options.dir.server || "server"))), "Importing from server middleware is not allowed in the Vue part of your app."]
];
const ImportProtectionPlugin = createUnplugin(function(options) {
  const cache = {};
  return {
    name: "nuxt:import-protection",
    enforce: "pre",
    resolveId(id, importer) {
      const invalidImports = options.patterns.filter(([pattern]) => pattern instanceof RegExp ? pattern.test(id) : pattern === id);
      let matched;
      for (const match of invalidImports) {
        cache[id] = cache[id] || /* @__PURE__ */ new Map();
        const [pattern, warning] = match;
        if (cache[id].has(pattern)) {
          continue;
        }
        const relativeImporter = isAbsolute(importer) ? relative(options.rootDir, importer) : importer;
        logger.error(warning || "Invalid import", `[importing \`${id}\` from \`${relativeImporter}\`]`);
        cache[id].set(pattern, true);
        matched = true;
      }
      if (matched) {
        return _require.resolve("unenv/runtime/mock/proxy");
      }
      return null;
    }
  };
});

const addModuleTranspiles = () => {
  const nuxt = useNuxt();
  const modules = [
    ...nuxt.options.buildModules,
    ...nuxt.options.modules,
    ...nuxt.options._modules
  ].map((m) => typeof m === "string" ? m : Array.isArray(m) ? m[0] : m.src).filter((m) => typeof m === "string").map((m) => m.split("node_modules/").pop());
  nuxt.options.build.transpile = nuxt.options.build.transpile.map((m) => typeof m === "string" ? m.split("node_modules/").pop() : m);
  function isTranspilePresent(mod) {
    return nuxt.options.build.transpile.some((t) => !(t instanceof Function) && (t instanceof RegExp ? t.test(mod) : new RegExp(t).test(mod)));
  }
  for (const module of modules) {
    if (!isTranspilePresent(module)) {
      nuxt.options.build.transpile.push(module);
    }
  }
};

function createNuxt(options) {
  const hooks = createHooks();
  const nuxt = {
    _version: version,
    options,
    hooks,
    callHook: hooks.callHook,
    addHooks: hooks.addHooks,
    hook: hooks.hook,
    ready: () => initNuxt(nuxt),
    close: () => Promise.resolve(hooks.callHook("close", nuxt)),
    vfs: {}
  };
  return nuxt;
}
async function initNuxt(nuxt) {
  nuxt.hooks.addHooks(nuxt.options.hooks);
  nuxtCtx.set(nuxt);
  nuxt.hook("close", () => nuxtCtx.unset());
  const { initNitro } = await (nuxt.options.experimentNitropack ? import('./nitro-nitropack.mjs') : import('./nitro-legacy.mjs'));
  await initNitro(nuxt);
  nuxt.hook("prepare:types", (opts) => {
    opts.references.push({ types: "nuxt3" });
    opts.references.push({ path: resolve(nuxt.options.buildDir, "types/plugins.d.ts") });
    if (nuxt.options.typescript.shim) {
      opts.references.push({ path: resolve(nuxt.options.buildDir, "types/vue-shim.d.ts") });
    }
    opts.references.push({ path: resolve(nuxt.options.buildDir, "types/schema.d.ts") });
  });
  const config = {
    rootDir: nuxt.options.rootDir,
    patterns: vueAppPatterns(nuxt)
  };
  addVitePlugin(ImportProtectionPlugin.vite(config));
  addWebpackPlugin(ImportProtectionPlugin.webpack(config));
  await nuxt.callHook("modules:before", { nuxt });
  const modulesToInstall = [
    ...nuxt.options.buildModules,
    ...nuxt.options.modules,
    ...nuxt.options._modules
  ];
  addComponent({
    name: "NuxtWelcome",
    filePath: resolve(nuxt.options.appDir, "components/nuxt-welcome.vue")
  });
  addComponent({
    name: "ClientOnly",
    filePath: resolve(nuxt.options.appDir, "components/client-only")
  });
  for (const m of modulesToInstall) {
    if (Array.isArray(m)) {
      await installModule(m[0], m[1]);
    } else {
      await installModule(m, {});
    }
  }
  await nuxt.callHook("modules:done", { nuxt });
  await addModuleTranspiles();
  await nuxt.callHook("ready", nuxt);
}
async function loadNuxt(opts) {
  const options = await loadNuxtConfig(opts);
  options.appDir = options.alias["#app"] = resolve(distDir, "app");
  options._majorVersion = 3;
  options._modules.push(pagesModule, metaModule, componentsModule, autoImportsModule);
  options.modulesDir.push(resolve(pkgDir, "node_modules"));
  options.alias["vue-demi"] = resolve(options.appDir, "compat/vue-demi");
  options.alias["@vue/composition-api"] = resolve(options.appDir, "compat/capi");
  const nuxt = createNuxt(options);
  if (opts.ready !== false) {
    await nuxt.ready();
  }
  return nuxt;
}
function defineNuxtConfig(config) {
  return config;
}

const vueShim = {
  filename: "types/vue-shim.d.ts",
  getContents: () => [
    "declare module '*.vue' {",
    "  import { DefineComponent } from '@vue/runtime-core'",
    "  const component: DefineComponent<{}, {}, any>",
    "  export default component",
    "}"
  ].join("\n")
};
const appComponentTemplate = {
  filename: "app-component.mjs",
  getContents: (ctx) => genExport(ctx.app.mainComponent, ["default"])
};
const rootComponentTemplate = {
  filename: "root-component.mjs",
  getContents: (ctx) => genExport(ctx.app.rootComponent, ["default"])
};
const cssTemplate = {
  filename: "css.mjs",
  getContents: (ctx) => ctx.nuxt.options.css.map((i) => genImport(i)).join("\n")
};
const clientPluginTemplate = {
  filename: "plugins/client.mjs",
  getContents(ctx) {
    const clientPlugins = ctx.app.plugins.filter((p) => !p.mode || p.mode !== "server");
    return [
      templateUtils.importSources(clientPlugins.map((p) => p.src)),
      `export default ${genArrayFromRaw(clientPlugins.map((p) => templateUtils.importName(p.src)))}`
    ].join("\n");
  }
};
const serverPluginTemplate = {
  filename: "plugins/server.mjs",
  getContents(ctx) {
    const serverPlugins = ctx.app.plugins.filter((p) => !p.mode || p.mode !== "client");
    return [
      "import preload from '#app/plugins/preload.server'",
      templateUtils.importSources(serverPlugins.map((p) => p.src)),
      `export default ${genArrayFromRaw([
        "preload",
        ...serverPlugins.map((p) => templateUtils.importName(p.src))
      ])}`
    ].join("\n");
  }
};
const appViewTemplate = {
  filename: "views/app.template.html",
  getContents() {
    return `<!DOCTYPE html>
<html {{ HTML_ATTRS }}>

<head {{ HEAD_ATTRS }}>
  {{ HEAD }}
</head>

<body {{ BODY_ATTRS }}>
  {{ APP }}
</body>

</html>
`;
  }
};
const pluginsDeclaration = {
  filename: "types/plugins.d.ts",
  getContents: (ctx) => {
    const EXTENSION_RE = new RegExp(`(?<=\\w)(${ctx.nuxt.options.extensions.map((e) => escapeRE(e)).join("|")})$`, "g");
    const tsImports = ctx.app.plugins.map((p) => (isAbsolute(p.src) ? relative(join(ctx.nuxt.options.buildDir, "types"), p.src) : p.src).replace(EXTENSION_RE, ""));
    return `// Generated by Nuxt3'
import type { Plugin } from '#app'

type Decorate<T extends Record<string, any>> = { [K in keyof T as K extends string ? \`$\${K}\` : never]: T[K] }

type InjectionType<A extends Plugin> = A extends Plugin<infer T> ? Decorate<T> : unknown

type NuxtAppInjections = 
  ${tsImports.map((p) => `InjectionType<typeof ${genDynamicImport(p, { wrapper: false })}.default>`).join(" &\n  ")}

declare module '#app' {
  interface NuxtApp extends NuxtAppInjections { }
}

declare module '@vue/runtime-core' {
  interface ComponentCustomProperties extends NuxtAppInjections { }
}

export { }
`;
  }
};
const adHocModules = ["router", "pages", "auto-imports", "meta", "components"];
const schemaTemplate = {
  filename: "types/schema.d.ts",
  getContents: ({ nuxt }) => {
    const moduleInfo = nuxt.options._installedModules.map((m) => ({
      ...m.meta || {},
      importName: m.entryPath || m.meta?.name
    })).filter((m) => m.configKey && m.name && !adHocModules.includes(m.name));
    return [
      "import { NuxtModule } from '@nuxt/schema'",
      "declare module '@nuxt/schema' {",
      "  interface NuxtConfig {",
      ...moduleInfo.filter(Boolean).map((meta) => `    [${genString(meta.configKey)}]?: typeof ${genDynamicImport(meta.importName, { wrapper: false })}.default extends NuxtModule<infer O> ? Partial<O> : Record<string, any>`),
      "  }",
      "}"
    ].join("\n");
  }
};

const defaultTemplates = {
  __proto__: null,
  vueShim: vueShim,
  appComponentTemplate: appComponentTemplate,
  rootComponentTemplate: rootComponentTemplate,
  cssTemplate: cssTemplate,
  clientPluginTemplate: clientPluginTemplate,
  serverPluginTemplate: serverPluginTemplate,
  appViewTemplate: appViewTemplate,
  pluginsDeclaration: pluginsDeclaration,
  schemaTemplate: schemaTemplate
};

function createApp(nuxt, options = {}) {
  return defu(options, {
    dir: nuxt.options.srcDir,
    extensions: nuxt.options.extensions,
    plugins: [],
    templates: []
  });
}
async function generateApp(nuxt, app) {
  await resolveApp(nuxt, app);
  app.templates = Object.values(defaultTemplates).concat(nuxt.options.build.templates);
  await nuxt.callHook("app:templates", app);
  app.templates = app.templates.map((tmpl) => normalizeTemplate(tmpl));
  const templateContext = { utils: templateUtils, nuxt, app };
  await Promise.all(app.templates.map(async (template) => {
    const contents = await compileTemplate(template, templateContext);
    const fullPath = template.dst || resolve(nuxt.options.buildDir, template.filename);
    nuxt.vfs[fullPath] = contents;
    const aliasPath = "#build/" + template.filename.replace(/\.\w+$/, "");
    nuxt.vfs[aliasPath] = contents;
    if (process.platform === "win32") {
      nuxt.vfs[fullPath.replace(/\//g, "\\")] = contents;
    }
    if (template.write) {
      await promises.mkdir(dirname(fullPath), { recursive: true });
      await promises.writeFile(fullPath, contents, "utf8");
    }
  }));
  await nuxt.callHook("app:templatesGenerated", app);
}
async function resolveApp(nuxt, app) {
  if (!app.mainComponent) {
    app.mainComponent = await findPath(["~/App", "~/app"]);
  }
  if (!app.mainComponent) {
    app.mainComponent = resolve(nuxt.options.appDir, "components/nuxt-welcome.vue");
  }
  app.rootComponent = resolve(nuxt.options.appDir, "components/nuxt-root.vue");
  app.plugins = [
    ...nuxt.options.plugins,
    ...await resolveFiles(nuxt.options.srcDir, [
      "plugins/*.{ts,js,mjs,cjs,mts,cts}",
      "plugins/*/index.*{ts,js,mjs,cjs,mts,cts}"
    ])
  ].map((plugin) => normalizePlugin(plugin));
  await nuxt.callHook("app:resolve", app);
}

async function build(nuxt) {
  const app = createApp(nuxt);
  await generateApp(nuxt, app);
  if (nuxt.options.dev) {
    watch(nuxt);
    nuxt.hook("builder:watch", async (event, path) => {
      if (event !== "change" && /app|plugins/i.test(path)) {
        if (path.match(/app/i)) {
          app.mainComponent = null;
        }
        await generateApp(nuxt, app);
      }
    });
    nuxt.hook("builder:generateApp", () => generateApp(nuxt, app));
  }
  await nuxt.callHook("build:before", { nuxt }, nuxt.options.build);
  if (!nuxt.options._prepare) {
    await bundle(nuxt);
    await nuxt.callHook("build:done", { nuxt });
  }
  if (!nuxt.options.dev) {
    await nuxt.callHook("close", nuxt);
  }
}
function watch(nuxt) {
  const watcher = chokidar.watch(nuxt.options.srcDir, {
    ...nuxt.options.watchers.chokidar,
    cwd: nuxt.options.srcDir,
    ignoreInitial: true,
    ignored: [
      isIgnored,
      ".nuxt",
      "node_modules"
    ]
  });
  const watchHook = (event, path) => nuxt.callHook("builder:watch", event, path);
  watcher.on("all", watchHook);
  nuxt.hook("close", () => watcher.close());
  return watcher;
}
async function bundle(nuxt) {
  const { bundle: bundle2 } = typeof nuxt.options.builder === "string" ? await tryImportModule(nuxt.options.builder, { paths: nuxt.options.rootDir }) : nuxt.options.builder;
  try {
    return bundle2(nuxt);
  } catch (error) {
    await nuxt.callHook("build:error", error);
    throw error;
  }
}

export { ImportProtectionPlugin as I, build as b, createNuxt as c, defineNuxtConfig as d, loadNuxt as l };
